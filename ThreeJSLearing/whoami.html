<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Three.js Ethanol Molecule</title>
    <style>
        /* 定义容器的大小 */
        #container {
            width: 800px;
            height: 600px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 30px;
            /* 添加圆角 */
            overflow: hidden;
            /* 防止边缘部分溢出 */
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 引入OrbitControls插件 -->
    <script
        src="https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/js/controls/OrbitControls.js"></script>

    <script>
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, 800 / 600, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(new THREE.Color(0x000000));
        renderer.setSize(800, 600);
        document.getElementById('container').appendChild(renderer.domElement);

        function createAtom(x, y, z, color) {
            const atomGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const atomMaterial = new THREE.MeshPhongMaterial({ color: color });
            const atom = new THREE.Mesh(atomGeometry, atomMaterial);
            atom.position.set(x, y, z);
            scene.add(atom);
            return atom;
        }

        // 创建键的函数
        function createBond(atom1, atom2, color) {
            const bondGeometry = new THREE.CylinderGeometry(0.1, 0.1, atom1.position.distanceTo(atom2.position), 8);
            const bondMaterial = new THREE.MeshBasicMaterial({ color: color });
            const bond = new THREE.Mesh(bondGeometry, bondMaterial);
            bond.position.copy(atom1.position).lerp(atom2.position, 0.5);
            const axis = new THREE.Vector3().subVectors(atom2.position, atom1.position);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), axis.normalize());
            bond.quaternion.copy(quaternion);
            bond.scale.z = atom1.position.distanceTo(atom2.position);
            scene.add(bond);
        }

        // 定义原子和化学键的颜色
        const colorCarbon = 0xcccccc;
        const colorHydrogen = 0x99ccff;
        const colorNitrogen = 0x3050F8;
        const colorOxygen = 0xFF0000;
        const colorBond = 0x999999;

        // 创建TNT分子的构造
        // 中心C3H5(NO2)3的组成方式
        var carbonAtoms = [];
        carbonAtoms.push(createAtom(-1, 0.5, 0, colorCarbon));
        carbonAtoms.push(createAtom(0, -0.5, 0, colorCarbon));
        carbonAtoms.push(createAtom(1, 0.5, 0, colorCarbon));

        createBond(carbonAtoms[0], carbonAtoms[1], colorBond);
        createBond(carbonAtoms[1], carbonAtoms[2], colorBond);

        var hydrogenAtoms = [];
        hydrogenAtoms.push(createAtom(0, -1.25, 1, colorHydrogen));
        hydrogenAtoms.push(createAtom(1, 1.25, 1, colorHydrogen));
        hydrogenAtoms.push(createAtom(-1, 1.25, 1, colorHydrogen));
        hydrogenAtoms.push(createAtom(1, 1.25, -1, colorHydrogen));
        hydrogenAtoms.push(createAtom(-1, 1.25, -1, colorHydrogen));

        createBond(carbonAtoms[1], hydrogenAtoms[0], colorBond);
        createBond(carbonAtoms[2], hydrogenAtoms[1], colorBond);
        createBond(carbonAtoms[2], hydrogenAtoms[3], colorBond);
        createBond(carbonAtoms[0], hydrogenAtoms[2], colorBond);
        createBond(carbonAtoms[0], hydrogenAtoms[4], colorBond);

        var oxygenAtoms = [];
        oxygenAtoms.push(createAtom(2, -0.5, 0, colorOxygen));
        oxygenAtoms.push(createAtom(0, -1.25, -1, colorOxygen));//1
        oxygenAtoms.push(createAtom(-2, -0.5, 0, colorOxygen));
        createBond(oxygenAtoms[0],carbonAtoms[2],colorBond);
        createBond(oxygenAtoms[1],carbonAtoms[1],colorBond);
        createBond(oxygenAtoms[2],carbonAtoms[0],colorBond);

        var nitrogenAtoms = [];
        nitrogenAtoms.push(createAtom(-3, 0.5, 0, colorNitrogen));
        nitrogenAtoms.push(createAtom(3, 0.5, 0, colorNitrogen));

        oxygenAtoms.push(createAtom(-3, 2, 0, colorOxygen));
        oxygenAtoms.push(createAtom(-4, -0.5, 0, colorOxygen));
        createBond(nitrogenAtoms[0], oxygenAtoms[2], colorBond);
        createBond(nitrogenAtoms[0], oxygenAtoms[3], colorBond);
        createBond(oxygenAtoms[4], nitrogenAtoms[0], colorBond);

        oxygenAtoms.push(createAtom(3, 2, 0, colorOxygen));
        oxygenAtoms.push(createAtom(4, -0.5, 0, colorOxygen));
        createBond(nitrogenAtoms[1], oxygenAtoms[0], colorBond);
        createBond(oxygenAtoms[5], nitrogenAtoms[1], colorBond);
        createBond(oxygenAtoms[6], nitrogenAtoms[1], colorBond);

        nitrogenAtoms.push(createAtom(0, -2, -2, colorNitrogen));//O[1]
        createBond(nitrogenAtoms[2], oxygenAtoms[1], colorBond);
        
        oxygenAtoms.push(createAtom(0, -1, -3, colorOxygen));
        oxygenAtoms.push(createAtom(0, -3.25, -2, colorOxygen));
        createBond(oxygenAtoms[7], nitrogenAtoms[2], colorBond);
        createBond(oxygenAtoms[8], nitrogenAtoms[2], colorBond);

        // 创建碳和氢之间的键
        //createBond(centralCarbon, hydrogens[0], colorBond);

        // 创建碳-氮键和氮-氧键
        //for (let i = 0; i < nitrogens.length; i++) {
        //  createBond(sideCarbons[i], nitrogens[i], colorBond);
        //  createBond(nitrogens[i], oxygens[i * 2], colorBond);
        //  createBond(nitrogens[i], oxygens[i * 2 + 1], colorBond);
        //}

        camera.position.z = 5;

        var ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        var directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.0);
        directionalLight.position.set(5, 3, 5);
        scene.add(directionalLight);

        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // 启用阻尼效果
        controls.dampingFactor = 0.25; // 设置阻尼系数
        controls.screenSpacePanning = false; // 禁用屏幕空间平移

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // 更新控制器状态
            renderer.render(scene, camera); // 渲染场景
        }

        animate();

        window.addEventListener('resize', function () {
            var width = window.innerWidth;
            var height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });

    </script>
</body>

</html>