<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Ethanol Molecule</title>
    <style>
        /* 定义容器的大小 */
        #container {
            width: 800px;
            height: 600px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 30px; /* 添加圆角 */
            overflow: hidden; /* 防止边缘部分溢出 */
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 引入OrbitControls插件 -->
    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/js/controls/OrbitControls.js"></script>

    <script>
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, 800 / 600, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(new THREE.Color(0x000000));
        renderer.setSize(800, 600);
        document.getElementById('container').appendChild(renderer.domElement);

        function createAtom(x, y, z, color) {
            var atomGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            var atomMaterial = new THREE.MeshToonMaterial({ color: color });
            var atom = new THREE.Mesh(atomGeometry, atomMaterial);
            atom.position.set(x, y, z);
            scene.add(atom);
            return atom;
        }

        function createBond(atom1, atom2) {
            var bondGeometry = new THREE.CylinderGeometry(0.1, 0.1, atom1.position.distanceTo(atom2.position), 8);
            var bondMaterial = new THREE.MeshBasicMaterial({ color: 0x999999 });
            var bond = new THREE.Mesh(bondGeometry, bondMaterial);

            bond.position.copy(atom1.position).lerp(atom2.position, 0.5);
            var axis = new THREE.Vector3().subVectors(atom2.position, atom1.position);
            var quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), axis.normalize());
            bond.quaternion.copy(quaternion);
            bond.scale.z = atom1.position.distanceTo(atom2.position);

            scene.add(bond);
        }

        var carbonAtoms = [];
        carbonAtoms.push(createAtom(0, 0, 0, 0xAAAAAA));
        carbonAtoms.push(createAtom(2, 0, 0, 0xAAAAAA));

        var oxygenAtom = createAtom(3, 1, 0, 0xFF0000);

        var hydrogenAtoms = [];
        hydrogenAtoms.push(createAtom(-1, 1, 0, 0xFFFFFF));
        hydrogenAtoms.push(createAtom(0, 1, 1, 0xFFFFFF));
        hydrogenAtoms.push(createAtom(0, -1, 1, 0xFFFFFF));
        hydrogenAtoms.push(createAtom(2, -1, 1, 0xFFFFFF));
        hydrogenAtoms.push(createAtom(2, 0, -1, 0xFFFFFF));
        hydrogenAtoms.push(createAtom(4, 1, 0, 0xFFFFFF));

        createBond(carbonAtoms[0], carbonAtoms[1]);
        createBond(carbonAtoms[1], oxygenAtom);
        createBond(oxygenAtom, hydrogenAtoms[5]);

        hydrogenAtoms.forEach(function(hydrogenAtom, idx) {
            if (idx < 5) { // Skip the last hydrogen as it's attached to oxygen
                createBond(carbonAtoms[Math.floor(idx / 3)], hydrogenAtom);
            }
        });

        camera.position.z = 5;

        var ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        var directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.0);
        directionalLight.position.set(5, 3, 5);
        scene.add(directionalLight);

        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // 启用阻尼效果
        controls.dampingFactor = 0.25; // 设置阻尼系数
        controls.screenSpacePanning = false; // 禁用屏幕空间平移

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // 更新控制器状态
            renderer.render(scene, camera); // 渲染场景
        }

        animate();
        
        window.addEventListener('resize', function() {
            var width = window.innerWidth;
            var height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });

    </script>
</body>
</html>